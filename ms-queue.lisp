(defmethod (setf resource-queue-tree) :before ((val resource) (queue resource-queue))
  (break)
)

(defmethod reset-queue ((queue resource-queue))
  (setf (resource-queue-tree queue) nil))

(defmethod resource< ((a resource) (b resource))
  (cond ((and (resource-latest-start-time a) (resource-latest-start-time b)
              (< (resource-latest-start-time a) (resource-latest-start-time b)))
         t)
        ((and (resource-latest-start-time a) (resource-latest-start-time b)
              (> (resource-latest-start-time a) (resource-latest-start-time b)))
         nil)
        ((and (resource-latest-end-time a) (resource-latest-end-time b))
         (< (resource-latest-end-time a) (resource-latest-end-time b)))))

(defmethod print-object ((object resource) (stream stream))
  (format stream "UID ~A Operator ~S Children ~A Started ~A Ended ~A"
          (resource-id object)
          (resource-type object)
          (length (resource-dependents object))
          (or (resource-start-time object)
              (number-not-inf (resource-earliest-start-time object))
              (number-not-inf (resource-latest-start-time object))
              )
          (or (resource-end-time object)
              (number-not-inf (resource-latest-end-time object))
              (number-not-inf (resource-earliest-end-time object))
              )))

;(defmethod schedule-resource ((item resource) (queue resource-queue))
;  (let ((pf (resource-queue-priority-func queue))
;        (cf (resource-queue-comparison-func queue))
;        (tree (resource-queue-tree queue)))
;    (cond (tree
;           (setf (resource-queue-tree queue) (rbt:insert-item item tree :test cf :key pf)))
;          (t
;           (let ((x (setf (resource-queue-tree queue) (rbt::init (rbt::make-rbt-node)))))
;             (setf (rbt::node-item x) item))))
;    queue
;))
(defmethod last-scheduled-resource ((queue resource-queue))
  (first (last (resource-queue-tree queue))))

(defmethod schedule-resource ((item resource) (queue resource-queue))
  (let* ((pos (position queue (flatten (as-list (processor-queues (get-processor)))))))
    (setf (resource-queue-number item) pos)
    (setf (resource-queue-tree queue) (append (resource-queue-tree queue) (list item)))))

(defmethod schedule-iroutine ((items hash-table) (proc processor))
  (let ((types nil)
        (grouped (make-hash-table)))
    (maphash #'(lambda (k v) (declare (ignore v))
                 (pushnew k types))
             (processor-queues proc))
    (maphash #'(lambda (k x) (declare (ignore k))
                 (push x (gethash (most-specific-superclass (resource-type x) types) grouped)))
             items)
    (maphash #'(lambda (type l)
                 (let ((items (sort l #'resource<)))
                   (loop for item in items
                         do (schedule-resource item (best-queue-for-resource proc type item)))))
             grouped)
    )
)

(defmethod best-queue-for-resource ((proc processor) (type activity-type) (res resource))
  (loop for queue in (gethash type (processor-queues proc))
        do (if (null (last-scheduled-resource queue))
               (return queue)
             (let ((l (last-scheduled-resource queue)))
               (cond ((and (resource-end-time l) (resource-start-time res)
                           (<= (resource-end-time l) (resource-start-time res)))
                      (return queue))
                     ((and (resource-end-time l) (resource-latest-start-time res)
                           (<= (resource-end-time l) (resource-latest-start-time res)))
                      (return queue))
                     ((and (resource-end-time l) (resource-earliest-start-time res)
                           (<= (resource-end-time l) (resource-earliest-start-time res)))
                      (return queue))
                     ((and (resource-latest-end-time l) (resource-start-time res)
                           (<= (resource-latest-end-time l) (resource-start-time res)))
                      (return queue))
                     ((and (resource-latest-end-time l) (resource-latest-start-time res)
                           (<= (resource-latest-end-time l) (resource-latest-start-time res)))
                      (return queue))
                     ((and (resource-latest-end-time l) (resource-earliest-start-time res)
                           (<= (resource-latest-end-time l) (resource-earliest-start-time res)))
                      (return queue)))))                 
        finally (return (first (gethash type (processor-queues proc))))))

(defun enumerate-helper (root)
  (if (and root (not (rbt:rbt-null root))) (append (enumerate-helper (rbt::left root))
                                                   (list (rbt::node-item root))
                                                   (enumerate-helper (rbt::right root))))
)

(defmethod enumerate ((queue resource-queue))
  (enumerate-helper (resource-queue-tree queue))
)


